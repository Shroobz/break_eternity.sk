options:
	max_e: 4 # at what amount of e's to use (e^layer)mag in format

on load:
	set {ExpLimit} to 9*10^15 # if mantissa is above this, increase a layer
	set {LayerDown} to log(9*10^15) # if layer isn't 0 and mantissa is below this, decrease a layer
	set {FirstNegLayer} to 1/(9*10^15) # At layer 0, smaller non-zero numbers than this become layer 1 numbers with negative mag
	


function normalize(n: numbers) :: numbers:
	# this explanation is from Patashu since I can't explain anything lmao
				# PSEUDOCODE:
        # Whenever we are partially 0 (sign is 0 or mag and layer is 0), make it fully 0.
        # Whenever we are at or hit layer 0, extract sign from negative mag.
        # If layer === 0 and mag < FIRST_NEG_LAYER (1/9e15), shift to 'first negative layer' (add layer, log10 mag).
        # While abs(mag) > EXP_LIMIT (9e15), layer += 1, mag = maglog10(mag).
        # While abs(mag) < LAYER_DOWN (15.954) and layer > 0, layer -= 1, mag = pow(10, mag).
        #       When we're done, all of the following should be true OR one of the numbers is not IsFinite OR layer is not IsInteger (error state):
        # Any 0 is totally zero (0, 0, 0).
        # Anything layer 0 has mag 0 OR mag > 1/9e15 and < 9e15.
        # Anything layer 1 or higher has abs(mag) >= 15.954 and < 9e15.
        # We will assume in calculations that all Decimals are either erroneous or satisfy these criteria. (Otherwise: Garbage in, garbage out.)
	if {_n::3} is 0:
		return (0, 0, 0)
	if {_n::1} and {_n::2} = 0: 
		return (0, 0, 0)
	if {_n::1} is 0: 
		if {_n::2} < 0: 
			set {_n::2} to {_n::2}*-1
			set {_n::3} to {_n::3}*-1
			return {_n::*}
		if {_n::2} < {FirstNegLayer}: 
			add 1 to {_n::1}
			set {_n::2} to log({_n::2})
			return {_n::*}
	set {_absmag} to abs({_n::2})
	set {_signmag} to Math_Sign({_n::2})
	if {_absmag} >= {ExpLimit}:
		add 1 to {_n::1}
		set {_n::2} to log({_absmag})*{_signmag}
		return {_n::*}
	else:
		if {_n::1} > 0:
			while {_absmag} < {LayerDown}:
				remove 1 from {_n::1}
				if {_n::1} = 0:
					set {_n::2} to 10^{_n::2}
					stop loop
				else:
					set {_n::2} to 10^{_n::2}
					set {_absmag} to abs({_n::2})
					set {_signmag} to Math_Sign({_n::2})
		if {_n::1} = 0:
			if {_n::2} < 0:
				set {_n::2} to {_n::2}*-1
				set {_n::3} to {_n::3}*-1
			else if {_n::2} = 0:
				set {_n::3} to 0
	return {_n::*}
 	
function isfinite(n: numbers) :: boolean: # checks for infinity
	return false if {_n::1} or {_n::2} is infinity value
	return false if {_n::3} isn't -1, 0 or 1
	return true

function createsupernum(layers: number = 0, mag: number = 0, sign: number = 0) :: numbers:
	if {_sign} = 0: # 0 = 0 :brain:
		set {_n::1} to 0
		set {_n::2} to 0
		set {_n::3} to 0
		return {_n::*}
	if {_sign} = 1 or -1: # that's crazy bro
		set {_n::1} to {_layers}
		set {_n::2} to {_mag}
		set {_n::3} to {_sign}
		return {_n::*}
	return NaN value # what else?
function breaketernityformat(n: numbers) :: string:
	if {_n::3} = 0: # returning 0 if number is 0
		return "0"
	if {_n::3} isn't -1, 0 or 1: # returning NaN if sign is illegal
		return "NaN"
	if {_n::1}, {_n::2} or {_n::3} isn't set: # returning NaN if not everything is set
		return "NaN" 
	if isfinite({_n::*}) is false:
		return "Infinity"
	if {_n::1} = 0:
		if abs({_n::2}*{_n::3}) is between 0.01 and 1000000:
			{_n::2} < 1000000 # 1m is scientific notation (because your mind can process up to 5 numbers instantly)
			return "%{_n::2}*{_n::3}%"
		return scientificnotation({_n::2}*{_n::3})
	if {_n::1} = 1:
		if {_n::2} < 1000000:
			{_n::2} > -1000000
			return "%10^({_n::2}-floor({_n::2}))*{_n::3}%e%floor({_n::2})%"
		if {_n::3} = 1: # removes the number before the first e and turns it into double scientific notation
			return "e%scientificnotation({_n::2})%"
		return "-e%scientificnotation({_n::2})%" # same as last conditional but negative
	if {_n::1} >= 2:
		if {_n::1} <= {@max_e}:
			set {_e} to "" # the {_e} part is "borrowed" from fantoccini
			loop {_n::1} times:
				set {_e} to "%{_e}%e"
			if {_n::2} >= 1000000: # if mag >= 1000000 add another layer of scientific notation
				if {_n::1}+1 >= {@max_e}: # if layers+1 >= max_e return breaketernityformat(layer+1, log(mag), sign)
					return breaketernityformat(createsupernum({_n::1}+1, log({_n::2}), {_n::3}))
				set {_e} to "%{_e}%e"
				set {_n::2} to log({_n::2})
			return "%{_e}%%{_n::2}%" if {_n::3} = 1
			return "-%{_e}%%{_n::2}%" # same as last line but negative
		return "(e^%{_n::1}%)%{_n::2}%" if {_n::3} = 1
		return "-(e^%{_n::1}%)%{_n::2}%" if {_n::3} = -1
	
function fromString(value: string) :: numbers: # ah shi, here we go again
	set {_originalValue} to {_value}
	# I'm supposed to do some LRUCache stuff right here but I don't even know what that is so we skip to x^^^y format yey!
	set {_pentationparts::*} to {_value} split at "^^^"
	if size of {_pentationparts::*} = 2:
		set {_base} to {_pentationparts::1} parsed as number
		set {_height} to {_pentationparts::2} parsed as number
		set {_heightparts::*} to {_pentationparts::2} split at ";"
		set {_payload} to 1
		if size of {_heightparts::*} = 2:
			set {_payload} to {_heightparts::2} parsed as number

			if {_payload} = infinity value:
				set {_payload} to 1
		if {_base} != infinity value:
			if {_height} != infinity value:
				parse if false = true: # pentation isn't added yet
					set {_result::*} to superpentate(({_base}, {_height}, {_payload}))
					set {_n::1} to {_result::1}
					set {_n::2} to {_result::2}
					set {_n::3} to {_result::3}
					return {_n::*} # dunno why patashu didn't just return result, we'll never know (unless he sees this)
	set {_tetrationparts::*} to {_value} split at "^^" # Handle x^^y format
	if size of {_tetrationparts::*} = 2:
		set {_base2} to {_tetrationparts::1} parsed as number
		set {_height2} to {_tetrationparts::2} parsed as number
		set {_heightparts::*} to {_tetrationparts::2} split at ";"
		set {_payload} to 1
		if size of {_heightparts::*} = 2:
			set {_payload} to {_heightparts::2} parsed as number
			if {_payload} = infinity value:
				set {_payload} to 1
		if {_base2} != infinity value:
			if {_height2} != infinity value:
				parse if false = true: # tetration is also not added yet
					set {_result::*} to supertetrate(({_base2}, {_height2}, {_payload}))
					set {_n::1} to {_result::1}
					set {_n::2} to {_result::2}
					set {_n::3} to {_result::3}
					return {_n::*} # hey! this is just pentate but with tetration! why didn't I copy and paste this!
	set {_powparts::*} to {_value} split at "^"
	if size of {_powparts::*} = 2:
		set {_base3} to {_powparts::1} parsed as number
		set {_exponent} to {_powparts::2} parsed as number

		if {_base3} != infinity value:
			if {_exponent} != infinity value:
				set {_result2::*} to superpow({_base3}, {_exponent})
				set {_n::1} to {_result2::1}
				set {_n::2} to {_result2::2}
				set {_n::3} to {_result2::3}
				return {_n::*}
	# Handle various cases involving it being a Big Number
	
	# set {_value} to {_value} in lowercase
	# set {_ptparts::*} to {_value} split at "pt" # Handle X PT Y format

	# if size of {_ptparts::*} = 2:

	
		





function scientificnotation(n: number) :: string: # most efficient scientific notation I know (that's a lie I can make this like 12% faster)
	return "0" if {_n} = 0 # return 0 if n is 0
	if {_n} > 0: # case for positive numbers
		set {_n2} to floor(log({_n}))
		set {_n} to log({_n})
		return "%10^({_n}-{_n2})%e%{_n2}%"
	else if {_n} < 0: # case for negative numbers
		set {_n} to abs({_n})
		set {_n2} to floor(log({_n}))
		set {_n} to log({_n})
		return "-%10^({_n}-{_n2})%e%{_n2}%"
	
# Placeholders used for testing below this line /-/

command normalize <number> <number> <number>:
	trigger:
		broadcast normalize((arg-1, arg-2, arg-3))	
command superformat <number> <number> <number>:
	trigger:
		broadcast breaketernityformat(createsupernum(arg-1, arg-2, arg-3))
	
on join:
	wait 3 seconds
	set {money::%player's uuid%::*} to createsupernum(20, 1, 1)
	while player is online:
		wait 4 ticks
		set title of player's scoreboard to "numbatest"
		set {money::%player's uuid%::2} to {money::%player's uuid%::2}/5000000
		set {money::%player's uuid%::*} to normalize({money::%player's uuid%::*})
		broadcast ""
		broadcast {money::%player's uuid%::*}
		set line 1 of player's scoreboard to breaketernityformat({money::%player's uuid%::*})
		
